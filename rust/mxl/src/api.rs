// SPDX-FileCopyrightText: 2025 2025 Contributors to the Media eXchange Layer project.
// SPDX-License-Identifier: Apache-2.0

//! MXL API loading and dynamic library management.
//!
//! This module provides functions to dynamically load the MXL C library at runtime
//! and obtain a shared handle to its FFI functions.

use std::{path::Path, sync::Arc};

use mxl_sys::libmxl;

use crate::Result;

/// Type alias for the dynamically-loaded MXL C API function table.
///
/// This is generated by `libloading` and `bindgen` to provide Rust bindings
/// to all functions in the MXL C library.
pub type MxlApi = libmxl;

/// Thread-safe shared handle to the loaded MXL API.
///
/// Multiple [`crate::MxlInstance`] objects can share the same `MxlApiHandle`,
/// allowing efficient reuse of the loaded dynamic library across threads.
pub type MxlApiHandle = Arc<MxlApi>;

/// Dynamically loads the MXL C library from the specified path.
///
/// This function uses `libloading` to open the shared object file and bind
/// all MXL C functions. The returned handle is reference-counted and can be
/// cloned to share the loaded library across multiple instances.
///
/// # Arguments
///
/// * `path_to_so_file` - Path to `libmxl.so` (or platform equivalent)
///
/// # Returns
///
/// A shared handle to the loaded MXL API on success.
///
/// # Errors
///
/// Returns [`crate::Error::LibLoading`] if:
/// - The file does not exist or cannot be opened
/// - Required symbols are missing from the library
/// - The library is incompatible with the current platform
///
/// # Safety
///
/// This function is safe to call, but internally uses `unsafe` to load the
/// dynamic library. The caller must ensure the provided library is a valid
/// MXL implementation matching the expected ABI.
///
/// # Examples
///
/// ```no_run
/// use mxl::load_api;
///
/// # fn main() -> Result<(), mxl::Error> {
/// let api = load_api("/usr/local/lib/libmxl.so")?;
/// # Ok(())
/// # }
/// ```
pub fn load_api(path_to_so_file: impl AsRef<Path>) -> Result<MxlApiHandle> {
    Ok(Arc::new(unsafe {
        libmxl::new(path_to_so_file.as_ref().as_os_str())?
    }))
}
